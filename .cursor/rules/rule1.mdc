---
description:
globs:
alwaysApply: false
---

# General Principles

All components must be functional (function components) and hook-based. Class components are strictly prohibited. Each component should have a single responsibility (Single Responsibility Principle). UI content should be 100% Turkish by default, but multilingual (i18n) support must be planned and infrastructure kept ready. Semantic HTML tags such as `<main>`, `<section>`, `<header>`, `<footer>`, `<article>` are mandatory. Unnecessary `<div>` usage should be avoided. Code should be concise, clear, DRY (Do not Repeat Yourself), and readable. Avoid unnecessary comments, but provide brief and clear explanations for complex flows or important blocks. Avoid unnecessary dependencies; only essential helper libraries may be added (e.g., Headless UI). Component and function names should follow universal coding standards in English, while all UI text should be in Turkish. Read all the components and understand the duties I give you before you start coding.

# Project Purpose

Build a modern, scalable, cloneable e-commerce platform combining features of Trendyol (multi-vendor discovery, campaigns) and Shopier (seller-based stores). The goal is to make a commercial-grade platform that can be sold, cloned, or productized later.

# Technical Goals

- Use React, React Router, Tailwind CSS, Supabase, and React Query.
- Support dynamic routing, lazy loading, code splitting, and performance optimization.
- Use semantic HTML and accessibility best practices.
- Use domain-driven file structure.
- Apply modern UI/UX rules and fully responsive design.
- Follow DRY, SRP, and clean code principles.
- Turkish as the main language, i18n-ready for future multi-language support.

# Functional Requirements

- Guest users can browse products without login.
- Users can sign up, manage profiles, addresses, favorites, and orders.
- Sellers can log in, add/update/delete their products, view analytics, and manage orders.
- Admins can review seller applications, manage the platform, and access dashboards.
- Homepage features trending products, category filters, personalized views, and infinite scroll.
- Product detail pages include description, specs, reviews, and variants.
- Checkout flow includes cart, discount logic, and order success screen.
- Notifications: post-order feedback, comment prompts, review requests.
- Future features like AI recommendations, push notifications, and campaigns will be scaffolded but disabled.

# Monetization Model

- Each seller gets their own public store page (like Shopier).
- Platform supports monetization via commissions, seller subscriptions, or storefront tiers.
- The entire architecture is white-label-ready for niche clones.

# Developer Goal

- This platform will be a portfolio-level, production-ready, scalable architecture.
- The code should be clear, maintainable, and testable.
- Every feature should be designed with real-world usage and commercial success in mind.

## Supabase & Database Rules

- **Tables and dependencies:** When creating tables via Supabase SQL Editor, always ensure dependency order is correct. For example, create base lookup or relational tables first (e.g., `users`, `addresses`) before dependent tables (e.g., `orders`, `cargo_items`).
- **Fresh start scripts:** Always provide a **cleanup SQL file** that safely drops all related tables, policies, triggers, and buckets before creating new ones. This avoids duplicate `create table` errors and conflicts.
- **Policy sequencing:** Define row-level security (RLS) policies only after the related tables and columns are fully created and verified.
- **Buckets and storage:** Buckets must be created only after related tables are confirmed and references are set up. Never create buckets in parallel to avoid dependency issues.
- **Cursor behavior mitigation:** Explicitly check for existing objects and use conditional `DROP IF EXISTS` statements in SQL. All SQL instructions must be grouped together in consistent, reusable migration files instead of separate, isolated prompts.

## Import & Export Consistency Rules

- Always ensure **import and export styles are consistent**. For example, do not mix `export default` with named imports or vice versa.
- Use **named exports consistently** for all hooks, utils, and shared components. Reserve `export default` only for top-level pages or large container components.
- At each file's end, validate that all declared exports match actual imports. Never leave unreferenced or unused exports in any module.

## Path & Navigation Consistency

- When creating a new file or folder, **always create corresponding import paths and parent index files** to maintain clear navigation and avoid unresolved import errors.
- If creating a nested path (e.g., `features/orders/components`), also create an `index.ts` file that exports all inner modules clearly.
- Avoid relative imports jumping multiple levels (e.g., `../../../`); use alias imports defined in `tsconfig.json` (`@/components/...`) for consistency.

## Code Integrity Check

- After each operation (new feature, table, policy, or code change), run an **automated consistency check** to detect:
  - Unused imports or exports
  - Circular dependencies
  - Mismatched types or missing TypeScript declarations
  - Broken or missing imports
  - Conflicting or orphaned files
- Refactor and clean up before proceeding to the next feature prompt.

# Performance and Load Optimization##

Page- or component-based code splitting should be applied. Lazy loading should be used for modals, charts, and detail components. Use React.memo, useMemo, and useCallback to prevent unnecessary renders in components with computational logic. Virtualization is recommended for large lists and tables (react-window, react-virtualized). Images should be responsive, use modern formats (e.g., WebP, AVIF), and support srcset. Avoid unnecessary large imports; apply minimal import principles. Do not change existing imports unnecessarily; maintain consistent usage of named or default exports. Build size and loading time should be regularly monitored with tools like Lighthouse and Bundle Analyzer.

# Tailwind CSS Usage Rules##

Utility class usage must be consistent; avoid complex and lengthy class chains. Frequently used combinations should be grouped in Tailwind config with @apply (only for patterns repeated 3 or more times). CSS-in-JS and inline styles should not be used; however, dynamic styles (e.g., dynamic style={{ '--custom-color': dynamicColor }}) are allowed. Design should be mobile-first and fully responsive. Class order should be: Layout > Box Model > Typography > Visual > Animation. Animations should only use Tailwind’s transition and animation classes; avoid heavy JS animations.

# Error Handling & Security##

- Global error boundary kullanılması zorunludur; kullanıcıya Türkçe, anlaşılır hata ekranı gösterilmelidir.
- API çağrılarında React Query `onError` kullanımı veya custom global error hook önerilir. Tüm hatalar merkezi olarak yakalanmalı ve kullanıcıya "Bir hata oluştu, lütfen tekrar deneyin." gibi net Türkçe mesaj verilmelidir.
- JWT validasyonu frontend ve backend tarafında yapılmalıdır. Supabase `supabase.auth.getUser()` ile session kontrolü yapılır.
- Supabase Row-Level Security (RLS) aktif olmalı, kullanıcı sadece kendi verisini görebilmelidir.
- Kullanıcı girdileri sanitize edilmeli, temel güvenlik önlemleri (XSS ve CSRF koruması) uygulanmalıdır.

# Database Migration & Seed##

- Migration dosyaları versiyonlanmış ve açık isimlendirilmiş olmalıdır (örn: `001_initial_schema.sql`, `002_add_orders.sql`).
- Gerekirse cleanup için genel bir `cleanup.sql` dosyası bulunmalıdır.
- Seed script'leri demo veri oluşturmak için kullanılabilir. Tekrar çalıştırıldığında sorun çıkarmamalıdır.
- Base tablolar (örn: `users`) önce, dependent tablolar (örn: `orders`) sonra oluşturulmalıdır.
- Migration ve seed script'leri sürüm kontrolünde tutulmalıdır.

# Notifications##

- Kullanıcı aksiyonlarına bağlı bildirim altyapısı hazırlanmalıdır (örn: sipariş sonrası bilgilendirme).
- Bildirim mesajları Türkçe ve anlaşılır olmalıdır (örn: "Siparişiniz kargoya verildi!").
- Kullanıcı panelinde basit bildirim listesi gösterilmelidir.
- İleride push notification veya e-posta entegrasyonu planlanabilir, ancak şu an zorunlu değildir.

# Accessibility##

Semantic HTML tags are mandatory: `<button>`, `<label>`, `<fieldset>`, `<legend>`, etc. All interactive elements must have aria-\* attributes (e.g., aria-label, aria-expanded, aria-live). All buttons and inputs must be keyboard accessible (tab navigation). Contrast ratios must meet WCAG AA or AAA standards. Focus trap must be implemented in modals and similar components. Regular accessibility and SEO audit and improvement cycles must be maintained.

# File and Code Structure##

Domain-driven (feature-based) folder structure should be used. File and component naming must be meaningful, clear, and consistent. Test files should be named ComponentName.test.jsx and located in the same folder as the component. All functions should be kept short and accompanied by descriptive English comments.

# State Management##

useState is preferred for simple state management. useReducer is recommended for more complex local state. Flexibility in global state management should be ensured; if 4 or more components share state, use Context API or Zustand. For complex and high-performance projects, Redux or similar alternatives may be considered. React Query is mandatory for server state management.

# Forms and Validation##

Use native HTML validation (required, pattern, etc.) for simple inputs. Write minimal custom validators for complex validations. All error and warning messages and UI explanations must be 100% Turkish and clear. `<label for="id">` and `<input id="id">` structure is mandatory.

# Testing Rules##

Unit tests: Jest + React Testing Library (minimum 80% coverage recommended). Tests should prioritize critical functions and components. E2E tests: Cypress (critical paths mandatory). Test files should be named ComponentName.test.jsx and located in the same folder.

# Documentation##

Storybook is mandatory for all components. PropTypes or TypeScript type definitions are required. Complex logic must be explained with English comments. Documentation and test coverage should be planned flexibly according to project timeline.

# SEO and Readability##

Every page must have complete meta title, description, OG, and Twitter card tags. Proper heading hierarchy must be maintained (only one `<h1>` per page). Link texts should be meaningful and supported by aria-label. Canonical tags should be added on necessary pages. All images must have descriptive alt attributes. Regular SEO audit and improvement cycles are required.

# Monitoring and Performance Tracking##

Lighthouse scores for performance, accessibility, and SEO should be monitored regularly. React Profiler should be used for render analysis. Minimal user behavior analytics tools (e.g., umami, plausible) can be integrated.

# Comments and Documentation##

All functions, hooks, and critical blocks should include English comments. For complex flows, short explanations answering “Why?” and “What does it do?” should be added.

# Example Comment Format##

/\*\*

- Triggered when the "Sign Up" button in the UI is clicked.
- Registers the user via backend API and reports the result.
  \*/
